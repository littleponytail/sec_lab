#include <iostream>
#include <fstream>
#include <string>
#include <io.h>
#include <stdio.h>
#include <filesystem>



using namespace std;

class File;

class Competitor {
	int team_num;
	string name;
	int age;
	double weight;

	friend File;
public:
	Competitor(string name, int articul, int quantuty, double price);
	Competitor() {};
	void PrintInfo() {
		cout << "Name: " << name << endl;
		cout << "Number: " << team_num << endl;
		cout << "Weight: " << weight << endl;
		cout << "Age: " << age << endl;
	}
	bool operator <(Competitor& other) {
		if (this->team_num < other.team_num) {
			return true;
		}
		else {
			return false;
		}
	}

	bool operator >(Competitor& other) {
		if (this->team_num > other.team_num) {
			return true;
		}
		else {
			return false;
		}
	}

	bool operator ==(Competitor& other) {
		if (this->team_num == other.team_num) {
			return true;
		}
		else {
			return false;
		}
	}

	bool operator !=(Competitor& other) {
		if (this->team_num != other.team_num) {
			return true;
		}
		else {
			return false;
		}
	}

	friend std::ostream& operator<<(std::ostream& out, const Competitor& shoes);
	
};

class Exception
{
private:
	int error;

public:
	Exception()
	{
		error = 0;
	}
	Exception(int error)
	{
		this->error = error;
	}
	void what()
	{
		if (error == 1)
		{
			cout << "Cant insert Dublicate!" << endl;
		}
		if (error == 2)
		{
			cout << "No such value!" << endl;
		}
		if (error == 3)
		{
			cout << "Pointer is empty" <<endl;
		}
		if (error == 4)
		{
			cout << "File wasn`t open" << endl;
		}
		if (error==5)
		{
			cout << "Ring is empty" << endl;
		}
	} 	
	void check_rerror(int error) {
		this->error = error;
	}
};

template <class T>
class Iterator;
template <class T>
class Ring;

template <typename T>
class  Node
{

	Node* nexta;
public:
	Node* getnexta() {
		return nexta;
	};
	void setnexta(Node* nexta) { this->nexta = nexta; }
	T data;
	Node() : data(), nexta(nullptr) { }
	Node(T d) : data(d), nexta(nullptr) { }
};


template<class T>
class Ring
{
private:
	Node<T>* head;
	int size;
public:
	Ring() :head(nullptr), size(0) {}
	void add(T input)
	{
		if (head == nullptr) {
			Node<T>* element = new Node<T>(input);
			element->setnexta(head);
			head = element;
			size++;
		}
		else
		{
			Node<T>* tmp = head;
			int i = 0;
			while (i < size - 1) { tmp = tmp->getnexta(); i++; }
			tmp->setnexta(new Node<T>(input));
			tmp = tmp->getnexta();
			tmp->setnexta(head);
			size++;
		}
	}
	void mydelete()
	{
		if (size == 0)
			throw 5;
		Node<T>* tmp = head;
		head = head->getnexta();
		delete tmp;
		size--;
		Node<T>* t = head;
		int i = 0;
		while (i < size - 1)
		{
			t = t->getnexta();
			i++;
		}
		t->setnexta(head);

	}
	void output()
	{
		if (size == 0)
			throw 5;
		Node<T>* temp = head;
		int i = 0;
		while (i < size)
		{
			cout << "   " << temp->data;
			temp = temp->getnexta();
			i++;
		}
	}
	void twice_output() {
		if (size == 0)
			throw Exception();
		Node<T>* temp = head;
		int i = 0;
		while (i < 2 * size)
		{
			std::cout << "   " << temp->data;
			temp = temp->getnexta();
			i++;
		}
	}
	Node<T>* get_node() {
		return head;
	}
	int get_size() {
		return size;
	}

};

template<class T>
class Iterator
{
private:
	Node<T>* node;
	int size;
	int current;
public:
	friend Ring<T>;
	Iterator(Ring<T>* element) : current(0)
	{
		node = element->get_node();
		size = element->get_size();
	}
	void begin()
	{
		if (size == 0)
			throw 1;
		if (current != 0)
		{
			while (current < size)
			{
				current++;
				node = node->getnexta();
			}
			current = 0;
		}

	}
	void end() {
		if (size == 0)
			throw 1;
		if (current != 0)
		{
			while (current < size)
			{
				current++;
				node = node->getnexta();
			}
			current = 0;
		}
	}
	void search(T searched)
	{
		if (size == 0)
			throw 1;
		int i = 0;
		while (i < size)
		{
			if (!(searched > node->data) && !(searched < node->data))
			{
				std::cout << "\nHere it is\n " << node->data << endl;
				return;
			}
			if (current == size - 1)
				current = 0;
			else
				current++;
			node = node->getnexta();
			i++;
		}
		std::cout << "\n Nothing was founded" << endl;
		throw 2;
	}
	Iterator& operator++()
	{
		if (size == 0)
			throw Exception();
		if (size == 1)
			current = 0;
		else
			current++;
		node=node->getnexta();
		return *this;
	}
	T operator*() {
		return node->data;
	}
	void operator = (T x)
	{
		if (size == 0) throw 1;
		node->data = x;
	}
	Iterator& operator[](int index)
	{
		if (size == 0) throw 1;
		if (index > size) throw 3;
		Node<T>* tmp = node;
		while (1)
		{
			if (current == index)
			{
				node = tmp;
				return *this;
			}
			tmp = tmp->getnexta();
			if (current == size - 1)
				current = 0;
			else
				current++;
		}
	}
	T GetValue() {
		if (node == nullptr) {
			throw 3;
		}
		return node->data;
	}
	void shell()
	{
		T temp;
		if (size == 0)
			throw 1;
		int step, i, j;
		for (step = size / 2; step > 0; step /= 2)
			for (i = step; i < size; i++)
				for (j = i - step; j >= 0 && (*this)[j].node->getnexta()->data > ((*this)[j + step]).node->getnexta()->data; j -= step)
				{
					temp = (*this)[j].node->getnexta()->data;
					(*this)[j].node->getnexta()->data = ((*this)[j + step]).node->getnexta()->data;
					(*this)[j + step].node->getnexta()->data = temp;
				}
	}
};

class File {
	string path;
	fstream file;
	int CountElementOfBinFile();
	void GetElementOfBinFile(Competitor& comp);
public:
	File(std::string filePath);
	void ReadTextFormat();
	void WriteTextFormat(const Competitor& comp);
	void ReadBinFormat();
	void ReadBinFormat(int);
	void WriteBinFormat(const Competitor& comp);
	void sort_weight();
	void Num_sort();
	void age_sort();
	void SortByName();
	void SortByName(string);
	void InfoBeforePrice(double weight);
	int DelByName(string name);
	void FindByName(string name);
	
};

int main() {
	File file1("T1.txt");
	File file2("T2.txt");
	File file3("B.bin");

	Ring<Competitor> ring;
	ring.add(Competitor("Andrew", 2, 87, 35));
	ring.add(Competitor("Nick", 1, 98, 25));
	ring.add(Competitor("Mike", 1, 89, 30));
	ring.add(Competitor("Alex", 12,105, 40));
	ring.add(Competitor("Vova", 13, 100, 40));

	Iterator<Competitor> it(&ring);
	int place = 0;
	while (1) {
		place++;
		if (place==ring.get_size()) {
			file1.WriteTextFormat(it.GetValue());
			break;
		}
		file1.WriteTextFormat(it.GetValue());
		++it;
	}

	it.begin();
	place = 0;
	while (1) {
		place++;
		if (place == ring.get_size()) {
			file2.WriteBinFormat(it.GetValue());
			break;
		}
		file2.WriteBinFormat(it.GetValue());
		++it;
	}

	it.begin();
	place = 0;
	while (1) {
		place++;
		if (place == ring.get_size()) {
			file3.WriteBinFormat(it.GetValue());
			break;
		}
		file3.WriteBinFormat(it.GetValue());
		++it;
	}

    std::cout << "Text File, Text format:\n" << "-------------------------\n";
	//file1.ReadTextFormat();
	//std::cout << "\nText File, bin format:\n" << "-------------------------\n";
	//file2.ReadBinFormat();
	std::cout << "Bin File:\n" << "-------------------------\n";
	file3.ReadBinFormat();
	/*file3.SortByName();
	std::cout << "Sorted by name:\n" << "-------------------------\n";
	file3.Num_sort();
	file3.ReadBinFormat();
	std::cout << "Sorted by num:\n" << "-------------------------\n";
	file3.ReadBinFormat();
	std::cout << "Find by name:\n" << "-------------------------\n";
	file3.FindByName("Andrew");*/
	int size=file3.DelByName("Mike");
	/*FILE* output;
	fopen_s(&output, "B.bin", "wb");
	_chsize(_fileno(output), 122);
	fclose(output);*/
	//File file4("B.bin");
	std::cout << "del:\n" << "-------------------------\n";
	file3.ReadBinFormat();
	
}

void File::GetElementOfBinFile(Competitor& temp) {
	int len, beg;
	file.read((char*)&temp.team_num, sizeof(int));
	file.read((char*)&temp.age, sizeof(int));
	file.read((char*)&temp.weight, sizeof(double));
	file.read((char*)&len, sizeof(int));
	char* nam = new char[len + 1];
	file.read(nam, len);
	nam[len] = '\0';
	temp.name = nam;

	delete[] nam;
}
int File::DelByName(string name) {
	SortByName(name);
	int size = 0, size2, size3;

	try {
		file.open(path, std::ios::in | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return 0;
	}
	file.seekg(0, std::ios::end);
	int fileSize = file.tellg();
	file.seekg(0, std::ios::beg);
	Competitor next, next1;
	
	GetElementOfBinFile(next);
	
	while (file.tellg() < fileSize) {
		
		size2 = file.tellg();
		GetElementOfBinFile(next1);
		size3 = file.tellg();
		size++;
	}
	/*fopen_s(&output, "B.bin", "wb");
	_chsize(_fileno(output), 98);
	fclose(output);*/
	/*while(file.tellg() < fileSize) {
	file.write(" ",2);
	size2++;
	}*/
	//write(file, buf, 0);
	file.close();

	return size2;


}

void File::Num_sort() {
	int fileSize = CountElementOfBinFile();

	try {
		file.open(path, std::ios::in | std::ios::out | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	Competitor cur, next;
	int curPos, nextPos;
	for (int i = 0; i < fileSize; i++) {
		for (int j = 0; j < fileSize - 1; j++) {
			curPos = file.tellg();
			GetElementOfBinFile(cur);
			nextPos = file.tellg();
			GetElementOfBinFile(next);

			if (cur.team_num > next.team_num) {
				file.seekp(curPos, std::ios::beg);

				file.write((char*)&next.team_num, sizeof(int));
				file.write((char*)&next.age, sizeof(int));
				file.write((char*)&next.weight, sizeof(double));
				int len = next.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(next.name.data(), len);
				nextPos = file.tellp();

				file.write((char*)&cur.team_num, sizeof(int));
				file.write((char*)&cur.age, sizeof(int));
				file.write((char*)&cur.weight, sizeof(double));
				len = cur.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(cur.name.data(), len);
			}
			file.seekg(nextPos, std::ios::beg);
		}
		file.seekg(0, std::ios::beg);
	}
	file.close();
}

void File::age_sort() {
	int fileSize = CountElementOfBinFile();

	try {
		file.open(path, std::ios::in | std::ios::out | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}
	Competitor cur, next;
	int curPos, nextPos;
	for (int i = 0; i < fileSize; i++) {
		for (int j = 0; j < fileSize - 1; j++) {
			curPos = file.tellg();
			GetElementOfBinFile(cur);
			nextPos = file.tellg();
			GetElementOfBinFile(next);


			if (cur.age > next.age) {
				file.seekp(curPos, std::ios::beg);

				file.write((char*)&next.team_num, sizeof(int));
				file.write((char*)&next.age, sizeof(int));
				file.write((char*)&next.weight, sizeof(double));
				int len = next.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(next.name.data(), len);
				nextPos = file.tellp();

				file.write((char*)&cur.team_num, sizeof(int));
				file.write((char*)&cur.age, sizeof(int));
				file.write((char*)&cur.weight, sizeof(double));
				len = cur.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(cur.name.data(), len);
			}
			file.seekg(nextPos, std::ios::beg);
		}
		file.seekg(0, std::ios::beg);
	}
	file.close();
}

void File::SortByName() {
	int fileSize = CountElementOfBinFile();

	try {
		file.open(path, std::ios::in | std::ios::out | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	Competitor cur, next;
	int curPos, nextPos;
	for (int i = 0; i < fileSize; i++) {
		for (int j = 0; j < fileSize - 1; j++) {
			curPos = file.tellg();
			GetElementOfBinFile(cur);
			nextPos = file.tellg();
			GetElementOfBinFile(next);


			if (std::strcmp(next.name.c_str(), cur.name.c_str()) < 0) {
				file.seekp(curPos, std::ios::beg);

				file.write((char*)&next.team_num, sizeof(int));
				file.write((char*)&next.age, sizeof(int));
				file.write((char*)&next.weight, sizeof(double));
				int len = next.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(next.name.data(), len);
				nextPos = file.tellp();

				file.write((char*)&cur.team_num, sizeof(int));
				file.write((char*)&cur.age, sizeof(int));
				file.write((char*)&cur.weight, sizeof(double));
				len = cur.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(cur.name.data(), len);
			}
			file.seekg(nextPos, std::ios::beg);
		}
		file.seekg(0, std::ios::beg);
	}
	file.close();
}

void File::SortByName(string name) {
	int fileSize = CountElementOfBinFile();

	try {
		file.open(path, std::ios::in | std::ios::out | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	Competitor cur, next;
	int curPos, nextPos;
	for (int i = 0; i < fileSize; i++) {
		for (int j = 0; j < fileSize - 1; j++) {
			curPos = file.tellg();
			GetElementOfBinFile(cur);
			nextPos = file.tellg();
			GetElementOfBinFile(next);


			if ( cur.name.c_str()==name) {
				file.seekp(curPos, std::ios::beg);

				file.write((char*)&next.team_num, sizeof(int));
				file.write((char*)&next.age, sizeof(int));
				file.write((char*)&next.weight, sizeof(double));
				int len = next.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(next.name.data(), len);
				nextPos = file.tellp();

				file.write((char*)&cur.team_num, sizeof(int));
				file.write((char*)&cur.age, sizeof(int));
				file.write((char*)&cur.weight, sizeof(double));
				len = cur.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(cur.name.data(), len);
			}
			file.seekg(nextPos, std::ios::beg);
		}
		file.seekg(0, std::ios::beg);
	}
	file.close();
}

void File::sort_weight() {
	int fileSize = CountElementOfBinFile();

	try {
		file.open(path, std::ios::in | std::ios::out | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}
	Competitor cur, next;
	int curPos, nextPos;
	for (int i = 0; i < fileSize; i++) {
		for (int j = 0; j < fileSize - 1; j++) {
			curPos = file.tellg();
			GetElementOfBinFile(cur);
			nextPos = file.tellg();
			GetElementOfBinFile(next);

			if (cur.weight > next.weight) {
				file.seekp(curPos, std::ios::beg);

				file.write((char*)&next.team_num, sizeof(int));
				file.write((char*)&next.age, sizeof(int));
				file.write((char*)&next.weight, sizeof(double));
				int len = next.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(next.name.data(), len);
				nextPos = file.tellp();

				file.write((char*)&cur.team_num, sizeof(int));
				file.write((char*)&cur.age, sizeof(int));
				file.write((char*)&cur.weight, sizeof(double));
				len = cur.name.length();
				file.write((char*)&len, sizeof(int));
				file.write(cur.name.data(), len);
			}
			file.seekg(nextPos, std::ios::beg);
		}
		file.seekg(0, std::ios::beg);
	}
	file.close();
}

Competitor::Competitor(std::string name, int team_num, int age, double weight) {
	this->name = name;
	this->team_num = team_num;
	this->weight = weight;
	this->age = age;
}

std::ostream& operator<<(std::ostream& out, const Competitor& comp) {
	out << "Name: " << comp.name << std::endl;
	out << "Number: " << comp.team_num << std::endl;
	out << "Weight: " << comp.weight << std::endl;
	out << "Age: " << comp.age << std::endl;
	return out;
}

File::File(string path) {
	this->path = path;
	file.open(path, ios::out | ios::trunc);
	file.close();
}

void File::ReadTextFormat() {

	try {
		file.open(path, ios::in);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	std::string data;
	while (std::getline(file, data)) {
		std::cout << data << std::endl;
	}
	file.close();
}

void File::WriteTextFormat(const Competitor& comp) {
	try {
		file.open(path, std::ios::out | std::ios::app);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	file << comp;
	file.close();
}

void File::FindByName(string name) {
	int fileSize = CountElementOfBinFile();

	try {
		file.open(path, ios::in | ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	Competitor temp;
	for (int i = 0; i < fileSize; i++) {
		GetElementOfBinFile(temp);
		if (std::strcmp(temp.name.data(), name.data()) == 0) {
			std::cout << temp << std::endl;
			return;
		}
	}

	file.close();
}


//void File::DelByName(std::string name) {
//	int fileSize = CountElementOfBinFile();
//
//	
//	Competitor cur, next;
//	int curPos, nextPos;
//	for (int i = 1; i < fileSize; i++) {
//		curPos = file.tellg();
//		GetElementOfBinFile(cur);
//		if (std::strcmp(cur.name.data(), name.data()) == 0) {
//			file.seekg(curPos, std::ios::beg);
//			int size = 0;
//			for (i; i < fileSize - 1; i++) {
//				curPos = file.tellg();
//				GetElementOfBinFile(cur);
//				nextPos = file.tellg();
//				GetElementOfBinFile(next);
//				size = curPos - nextPos;
//
//				file.seekp(curPos, std::ios::beg);
//
//				file.write((char*)&next.team_num, sizeof(int));
//				file.write((char*)&next.age, sizeof(int));
//				file.write((char*)&next.weight, sizeof(double));
//				int len = next.name.length();
//				file.write((char*)&len, sizeof(int));
//				file.write(next.name.data(), len);
//				nextPos = file.tellp();
//
//				file.write((char*)&cur.team_num, sizeof(int));
//				file.write((char*)&cur.age, sizeof(int));
//				file.write((char*)&cur.weight, sizeof(double));
//				len = cur.name.length();
//				file.write((char*)&len, sizeof(int));
//				file.write(cur.name.data(), len);
//
//				file.seekg(nextPos, std::ios::beg);
//			}
//
//			//chsize(_fileno(ioFile), size);
//			file.close();
//			return;
//		}
//	}
//
//	file.close();
//}

void File::ReadBinFormat() {
	int fileSize = CountElementOfBinFile();

	try {
		file.open(path, std::ios::in | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	Competitor temp;
	file.seekg(0, ios::end);
	int size = file.tellg();
	file.seekg(0, std::ios::beg);
	while (file.tellg() < size) {
		GetElementOfBinFile(temp);
		std::cout << temp << std::endl;
	}

	file.close();
}
void File::ReadBinFormat(int size) {

	try {
		file.open(path, std::ios::in | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	Competitor temp;
	//file.seekg(0, ios::end);
	//int size = file.tellg();
	file.seekg(0, std::ios::beg);
	while (file.tellg() < size) {
		GetElementOfBinFile(temp);
		std::cout << temp << std::endl;
	}

	file.close();
}
void File::WriteBinFormat(const Competitor& comp) {
	try {
		file.open(path, std::ios::out | std::ios::app | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return;
	}

	file.write((char*)&comp.team_num, sizeof(int));
	file.write((char*)&comp.age, sizeof(int));
	file.write((char*)&comp.weight, sizeof(double));
	int len = comp.name.length();
	file.write((char*)&len, sizeof(int));
	file.write(comp.name.data(), len);
	file.close();
}



int File::CountElementOfBinFile() {
	int size = 0;

	try {
		file.open(path, std::ios::in | std::ios::binary);
		if (!file.is_open()) {
			throw 4;
		}
	}
	catch (int index) {
		Exception ex(index);
		ex.what();
		return 0;
	}
	file.seekg(0, std::ios::end);
	int fileSize = file.tellg();
	file.seekg(0, std::ios::beg);

	while (file.tellg() < fileSize) {
		Competitor temp;
		GetElementOfBinFile(temp);
		size++;
	}

	file.close();
	return size;
}
